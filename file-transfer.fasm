
; fasm file-transfer.fasm && chmod +x file-transfer && ./file-transfer 6969

; TODO
;
; use `jle` instead of `je` when comparing lengths
;
; create the `/tmp/...` folder
;
; make macros hygenic (as in the push/pop their own registers)
; or go tell the caller to fuck off
;
; use a giant buffer for network recv and operate on that buffer instead of making syscalls all the time
;
; add an "uploading..." message on the upload page
;
; check TCP_NODELAY
;
; check the number of written bytes when sending data
;
; make it so that you can select multiple files for upload
;
; make proper use of GET and POST

; info
;
; https://flatassembler.net/docs.php
; http://bos.asmhackers.net/docs/FASM%20tutorial/preproc.html
;
; registers: https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture
; more registers: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
; rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14 (and more)

; debug tips
;
; omg you get NO SYMBOLS WTF
; no `main`, no `_start`, nothing
; if you don't believe me check with `nm`
;
; run with `strace`
;
; `readelf -e <file>` and find the `entry point address`
; then in `gdb <file>` put a breakpoint on that address `b *0x4000b0`
; then `run` and `tui enable` and `layout asm`
; and you will get an asm view
;
; less retarded debugger is `gf` executable is called `gf2` https://github.com/nakst/gf
; again, break on the entry point using `b *0x4000b0`
; switch to the `registers` tab
; start with `run`
; use `ni` for next step

format ELF64 executable

include "linux-comptime.inc"
include "util-comptime.inc"

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: data types
; https://flatassembler.net/docs.php?article=manual#1.2.1

1B equ db
2B equ dw
4B equ dd
8B equ dq

1byte equ byte
2bytes equ word
4bytes equ dword ; double word
8bytes equ qword ; quad word

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: return codes

RET_CODE_SUCC equ 0
RET_CODE_FAIL equ 1
RET_CODE_TCP_SOCKET_FAIL equ 2
RET_CODE_BIND_FAIL equ 3
RET_CODE_LISTEN_FAIL equ 4
;RET_CODE_ACCEPT_FAIL equ 5 ; no longer used
RET_CODE_SETSOCKOPT_FAIL equ 6
RET_CODE_CHDIR_FAIL equ 7
RET_CODE_FOLDER_CONTAINING_UPLOADED_FILES_DOESNT_EXIST equ 8
RET_CODE_FOLDER_CONTAINING_STATIC_CONTENT_DOESNT_EXIST equ 9
RET_CODE_BAD_NUMBER_OF_ARGUMENTS equ 10

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: server parameters

MAX_CONNECTIONS equ 5
SERVING_THREADS equ 20
URL_MAXLEN equ 128 ; in bytes
HEADER_LINE_MAXLEN equ 128 ; in bytes ; TODO currently this is not long enough for the cookies line
FILE_RECV_BUF equ 32 ; in bytes ; this dramatically affects client upload speed
CLIENT_UPLOAD_TIMEOUT_SEC equ 0
CLIENT_UPLOAD_TIMEOUT_USEC equ 500_000 ; 1_000_000 is 1sec
CLIENT_DOWNLOAD_TIMEOUT_SEC equ CLIENT_UPLOAD_TIMEOUT_SEC
CLIENT_DOWNLOAD_TIMEOUT_USEC equ CLIENT_UPLOAD_TIMEOUT_USEC

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: idkman

METHOD_GET equ 0
METHOD_POST equ 1

;;;;;;;;;;;;;;;;;;;;;;;;; comptime variables

;; TODO create lbl_id
;; then use lbl_id+=1 where called

;;;;;;;;;;;;;;;;;;;;;;;;; macros

macro print msg, msg_len {
    print_nnl msg, msg_len
    sys_write FILE_STDOUT, str_nl, str_nl.size
}

macro print_nnl msg, msg_len {
    sys_write FILE_STDOUT, msg, msg_len
}

macro create_tcp_socket {
;; returns: dword eax: sockfd

    local tcp_socket_ok ; now this macro can be called multiple times without any label errors

    sys_socket AF_INET, SOCKET_TYPE_TCP, 0 ;; only one TCP protocol exists so the last arguments stays at 0
    cmp rax, 0
    jge tcp_socket_ok
        sys_exit RET_CODE_TCP_SOCKET_FAIL
    tcp_socket_ok: ;; TODO try and use `$` or something similar so that the macro can be used more than once
}

;;;;;;;;;;;;;;;;;;;;;;;;; code section

segment readable executable

include "util-executable.inc"

entry main

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

main:
    print str_starting_program, str_starting_program_len


    ; command line args are put on the stack
    ; the very first item is the number of arguments
    pop [num_args]
    cmp [num_args], 2
    je .num_args_ok
        print str_error_num_args, str_error_num_args.size
        sys_exit RET_CODE_BAD_NUMBER_OF_ARGUMENTS
    .num_args_ok:

    pop rax ; path to file; useless

    pop [arg1] ; port as cstring

    fnc8 cstr_to_uint, [arg1]
    mov [arg_port], ax


    fnc8 \
        open_folder_read, \
        folder_static_content

    mov [folder_static_content_fd], rax
    cmp rax, 0
    jge .folder_static_content_ok
        print_nnl str_warn_folder_existance, str_warn_folder_existance.size
        print folder_static_content, folder_static_content.size
        sys_exit RET_CODE_FOLDER_CONTAINING_STATIC_CONTENT_DOESNT_EXIST
    .folder_static_content_ok:


    fnc8 \
        open_folder_read, \
        folder_uploaded_files

    mov [folder_uploaded_files_fd], rax
    cmp rax, 0
    jge .folder_ok
        print_nnl str_warn_folder_existance, str_warn_folder_existance.size
        print folder_uploaded_files, folder_uploaded_files.size
        sys_exit RET_CODE_FOLDER_CONTAINING_UPLOADED_FILES_DOESNT_EXIST
    .folder_ok:


    create_tcp_socket
    ;; returns: dword eax: sockfd
    mov qword [sockfd], rax

    ; make port reusable
    sys_setsockopt [sockfd], SOL_SOCKET, SO_REUSEPORT, one, sizeof_one
    cmp rax, 0
    jge setsockopt_ok
        sys_exit RET_CODE_SETSOCKOPT_FAIL
    setsockopt_ok:

    ;; servaddr.sin_family = AF_INET;
    mov word [servaddr.sin_family], AF_INET

    ; servaddr.sin_port = htons(PORT);
    ;
    ; ; convert endianness by hand
    ; ; 6969 -(to-hex)-> 0x1b39 -(convert-endianness)-> 0x391b -(to-dec)-> 14619
    ; mov word [servaddr.sin_port], 14619
    ;
    ; convert endianness
    mov ax, [arg_port]
    mov bh, ah
    mov ah, al
    mov al, bh
    mov [servaddr.sin_port], ax

    ;; servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    ;; INADDR_ANY is 0 therefore I give 0 fucks about endianness
    mov dword [servaddr.sin_addr], 0

    sys_bind [sockfd], servaddr, servaddr.size
    cmp rax, 0
    jz bind_is_ok
        sys_exit RET_CODE_BIND_FAIL
    bind_is_ok:

    sys_listen [sockfd], MAX_CONNECTIONS
    cmp rax, 0
    jz listen_is_ok
        sys_exit RET_CODE_LISTEN_FAIL
    listen_is_ok:

    rept (SERVING_THREADS-1) counter {
        sys_fork
        cmp rax, 0
        jnz is_parent_#counter
            ;; is child
            jmp serving_thread
        is_parent_#counter:
    }

    jmp serving_thread ; also use main thread to serve

    sys_close [folder_static_content_fd]
    sys_close [folder_uploaded_files_fd]

    sys_shutdown [sockfd], SHUT_RDWR
    sys_close [sockfd]

    sys_exit RET_CODE_SUCC

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

serving_thread:

    sys_accept [sockfd], cliaddr, cliaddr_size
    cmp rax, 0
    jg accept_is_ok
        ;; client is a piece of shit
        jmp serving_thread
    accept_is_ok:

    mov qword [connfd], rax

    ; set client upload timeout
    mov [tmp_timeval.tv_sec], CLIENT_UPLOAD_TIMEOUT_SEC
    mov [tmp_timeval.tv_usec], CLIENT_UPLOAD_TIMEOUT_USEC
    sys_setsockopt [connfd], SOL_SOCKET, SO_RCVTIMEO, tmp_timeval, tmp_timeval.size

    ; set client download timeout
    mov [tmp_timeval.tv_sec], CLIENT_DOWNLOAD_TIMEOUT_SEC
    mov [tmp_timeval.tv_usec], CLIENT_DOWNLOAD_TIMEOUT_USEC
    sys_setsockopt [connfd], SOL_SOCKET, SO_SNDTIMEO, tmp_timeval, tmp_timeval.size

    call receive_header

    sys_shutdown [connfd], SHUT_RDWR
    sys_close [connfd]

    jmp serving_thread

    sys_exit RET_CODE_SUCC

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

receive_header:

    sys_read [connfd], tmp_4B, tmp_4B.size

    ; print tmp_4B, tmp_4B.size

    cmp [tmp_4B], 'G'
    je .method_get ; assume GET

    ; cmp [tmp_4B], 'P'
    jmp .method_post ; assume POST

    .method_get:
        mov [method], METHOD_GET
        jmp .method_finished

    .method_post:
        sys_read [connfd], tmp_1B, tmp_1B.size ; get rid of ` `
        mov [method], METHOD_POST
        jmp .method_finished

    .method_finished:

    mov rcx, url
    mov [url.len], 0

    .receive_next_byte_from_url:
        push rcx ; TODO stupid
        sys_read [connfd], tmp_1B, tmp_1B.size
        pop rcx

        ; network error
        cmp rax, 0
        jl .url_received

        cmp [tmp_1B], ' '
        je .url_received

        mov al, [tmp_1B]
        mov [rcx], al

        inc rcx
        inc [url.len]

        cmp [url.len], URL_MAXLEN
        je .url_received ; TODO idk what the appropriate action is ; TODO terminating the connection is probably better

        jmp .receive_next_byte_from_url
    .url_received:

    ; put 0 at the end; don't worry we have enough mem
    mov byte [rcx], 0

    mov rdx, 0
    mov dl, [url.len]
    print url, rdx

    mov [multipart_boundary.len], 0
    mov [file_upload_filename.len], 0
    call read_rest_of_header

    ; ; len would be 0 if it was not found
    ; mov rdx, 0
    ; mov dl, [multipart_boundary.len]
    ; print multipart_boundary, rdx

    ; mov rdx, 0
    ; mov dl, [file_upload_filename.len]
    ; print file_upload_filename, rdx

    call handle_request

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_request:

    ; not going to check for edge cases since in that case the malicious user
    ; is going to get a response based on the random bullshit in memory

    cmp [method], METHOD_GET
    je .metod_is_get

    cmp [method], METHOD_POST ; we can save some performance by skipping this cmp
    je .method_is_post

    jmp .method_is_unknown

    .metod_is_get:
        call handle_request_get
        jmp .done

    .method_is_post:
        call handle_request_post
        jmp .done

    .method_is_unknown:
        call handle_page_404
        jmp .done
    
    .done:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_request_get:

    cmp [url.len], 1
    jne .no_need_to_fix_request
        ; not ideal but ok
        mov byte [url   ], '/'
        mov byte [url+ 1], 'i'
        mov byte [url+ 2], 'n'
        mov byte [url+ 3], 'd'
        mov byte [url+ 4], 'e'
        mov byte [url+ 5], 'x'
        mov byte [url+ 6], '.'
        mov byte [url+ 7], 'h'
        mov byte [url+ 8], 't'
        mov byte [url+ 9], 'm'
        mov byte [url+10], 'l'
        mov byte [url+11], 0
        mov [url.len], 11
    .no_need_to_fix_request:

    call handle_custom_page

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_request_post:

    cmp byte [url+1], '4' ; skipping past the `/`
    je .requested_script_file_upload

    cmp byte [url+1], '5'
    je .requested_script_file_download

    cmp byte [url+1], '6'
    je .requested_javascript_ls

    jmp .invalid_request
    
    .requested_script_file_upload:
        call handle_script_file_upload
        jmp .return

    .requested_script_file_download:
        call handle_script_file_download
        jmp .return

    .requested_javascript_ls:
        call handle_javascript_ls
        jmp .return

    .invalid_request:
        call handle_page_404
        jmp .return

    .return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_script_file_upload:
    sys_write [connfd], str_http_header_begin, str_http_header_begin.size
    sys_write [connfd], str_http_header_end, str_http_header_end.size

    call read_rest_of_header

    ; make sure there's a 0 at the end of the filename (we DO have enough mem in buf)
    mov rbx, 0
    mov bl, [file_upload_filename.len]
    mov rax, file_upload_filename
    add rax, rbx
    mov byte [rax], 0

    fnc88 \
        open_file_write_at, \
        [folder_uploaded_files_fd], \
        file_upload_filename

    mov [file_send_upload_fd], rax

    ; ; mov [tmp_8B], 0
    ; ; sys_sendfile [file_send_upload_fd], [connfd], tmp_8B, 1
    ; sys_sendfile [file_send_upload_fd], [connfd], 0, 1
    ; sys_exit rax

    handle_script_file_upload.copy_to_file_loop:

        sys_read [connfd], file_recv_buf, file_recv_buf.size
        cmp rax, 0
        jle handle_script_file_upload.copy_to_file_loop_done

        ; sys_write [file_send_upload_fd], file_recv_buf, file_recv_buf.size
        mov rdx, rax
        sys_write [file_send_upload_fd], file_recv_buf, rdx
    
    jmp handle_script_file_upload.copy_to_file_loop

    handle_script_file_upload.copy_to_file_loop_done:

    ; now we need to delete the last (`multipart_boundary.len` + 7["--"+"--"+"\n19"] + 1?["\r"]) characters

    sys_lseek [file_send_upload_fd], 0, SEEK_CUR
    mov [tmp_8B], rax ; current offset

    ; calc new size
    mov rcx, 0
    mov cl, [multipart_boundary.len]
    sub [tmp_8B], rcx
    sub [tmp_8B], 8

    sys_ftruncate [file_send_upload_fd], [tmp_8B]

    sys_close [file_send_upload_fd]

    mov rax, 0
    mov al, [multipart_boundary.len]

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_script_file_download:
    sys_write [connfd], str_http_header_begin, str_http_header_begin.size
    sys_write [connfd], str_http_header_attachment_begin, str_http_header_attachment_begin.size

    ; save file len
    mov rdx, 0
    mov dl, [url.len]

    ; save file name
    mov rsi, url
    ; skip slash and magic number
    add rsi, 2
    sub dl, 2
    push rsi ; push file name

    sys_write [connfd], rsi, rdx

    sys_write [connfd], str_http_header_attachment_end, str_http_header_attachment_end.size

    sys_write [connfd], str_http_header_end, str_http_header_end.size

    mov rsi, O_RDONLY

    pop rdi ; pop file name
    sys_openat [folder_uploaded_files_fd], rdi, rsi, 0
    mov [file_send_upload_fd], rax
    
    ; get file size
    sys_lseek [file_send_upload_fd], 0, SEEK_END
    mov [tmp_8B], rax

    ; go back to the start
    sys_lseek [file_send_upload_fd], 0, SEEK_SET

    ; TODO call this in a loop
    sys_sendfile [connfd], [file_send_upload_fd], 0, [tmp_8B]

    sys_close [file_send_upload_fd]

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_page_404:
    sys_write [connfd], str_http_header_begin_404, str_http_header_begin_404.size
    sys_write [connfd], str_http_header_end, str_http_header_end.size

    sys_write [connfd], str_html_page_404, str_html_page_404.size

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_custom_page:

    fnc88 \
        open_file_read_at, \
        [folder_static_content_fd], \
        (url+1) ; skip the `/`

    mov [tmp_fd], rax
    cmp rax, 0
    jge .file_exists
        ; file doesn't exist
        call handle_page_404
        jmp .return
    .file_exists:

    ; send headers
    sys_write [connfd], str_http_header_begin, str_http_header_begin.size
    sys_write [connfd], str_http_header_end, str_http_header_end.size

    ; get file size
    sys_lseek [tmp_fd], 0, SEEK_END
    mov [tmp_8B], rax

    ; go back to the start
    sys_lseek [tmp_fd], 0, SEEK_SET

    ; TODO call this in a loop
    sys_sendfile [connfd], [tmp_fd], 0, [tmp_8B]

    sys_close [tmp_fd]

    .return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_javascript_ls:
    sys_write [connfd], str_http_header_begin, str_http_header_begin.size
    sys_write [connfd], str_http_header_end, str_http_header_end.size

    .get_dir_entries:

        sys_getdents [folder_uploaded_files_fd], linux_dirent_buf, linux_dirent_buf.size
        cmp rax, 0
        je .no_more_dir_entries

        mov [read_dir_nread], rax

        mov [read_dir_bpos], 0

        .read_some_more:

            mov rax, [read_dir_nread]
            cmp [read_dir_bpos], rax
            jge .no_more_to_read

            ; move to the appropriate offset
            mov rax, linux_dirent_buf
            add rax, [read_dir_bpos]
            ; now this points to the relevant linux_dirent struct

            mov rbx, rax
            add rbx, linux_dirent_buf.offset.d_reclen
                mov rcx, 0
                mov cx, [rbx] ; this is now the reclen; reclen is 2bytes
                mov rbx, rcx
            add rbx, rax
            dec rbx
            mov bl, [rbx] ; this is now the d_type (1B)

            ; TODO see why the fuck does this not work
            ; cmp bl, DT_REG
            ; jne .read_some_more_next_item ; if it's not a regular file just skip it

            mov rbx, rax
            add rbx, linux_dirent_buf.offset.d_name ; name of file

            ; save filename
            mov [tmp_8B_a], rbx

            ; get filename len
            mov rcx, 0
            .try_next_char:
                cmp byte [rbx], 0
                je .last_char_reached
                inc rbx
                inc rcx
            jmp .try_next_char
            .last_char_reached:

            ; save filename len
            mov [tmp_8B], rcx

            sys_write [connfd], [tmp_8B_a], [tmp_8B]
            sys_write [connfd], str_nl, str_nl.size
            
            .read_some_more_next_item:

            ; move to the appropriate offset
            mov rax, linux_dirent_buf
            add rax, [read_dir_bpos]
            ; now this points to the relevant linux_dirent struct

            mov rbx, rax
            add rbx, linux_dirent_buf.offset.d_reclen
                mov rcx, 0
                mov cx, [rbx] ; this is now the reclen; reclen is 2bytes
                mov rbx, rcx

            ; mov rdx, [read_dir_nread] ; TODO this is wrong; it needs to be d_reclen
            add [read_dir_bpos], rbx
            
        jmp .read_some_more
        .no_more_to_read:

    jmp .get_dir_entries
    .no_more_dir_entries:

    sys_lseek [folder_uploaded_files_fd], 0, SEEK_SET ; reset folder state

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

read_rest_of_header:

    read_rest_of_header.read_next_line:

        call read_next_header_line

        mov rdx, 0
        mov dl, [header_line.len]
        print header_line, rdx

        cmp [header_line.len], 0
        je read_rest_of_header.return


        fnc818188 \
            extract_header_field, \
            str_header_line_multipart_boundary, \
            str_header_line_multipart_boundary.size, \
            header_line, \
            [header_line.len], \
            multipart_boundary, \
            multipart_boundary.len


        fnc818188 \
            extract_header_field, \
            str_header_line_file_upload_filename, \
            str_header_line_file_upload_filename.size, \
            header_line, \
            [header_line.len], \
            file_upload_filename, \
            file_upload_filename.len

        cmp rax, 0
        je .not_found_file_upload_filename

            ; if it has been found remove the last character (it's a `"`)

            cmp [file_upload_filename.len], 0
            je .not_found_file_upload_filename

            mov rax, file_upload_filename
            .replace_bad_characters: ; HTML is retarded since it switches some of the characters for some retarded codes
                                        ; we are going to avoid this altogether by replacing the bad characters beforehand
                
                cmp byte [rax], 0 ; end of string
                je .bad_chars_replaced

                ; replace ` ` with `_`
                cmp byte [rax], ' '
                je .replace_this_char
                
                cmp byte [rax], '"'
                je .replace_this_char

                cmp byte [rax], "'"
                je .replace_this_char

                jmp .char_replace_done
                .replace_this_char:
                    mov byte [rax], '_'
                .char_replace_done:

                inc rax

            jmp .replace_bad_characters
            .bad_chars_replaced:


            dec [file_upload_filename.len]

        .not_found_file_upload_filename:

    jmp read_rest_of_header.read_next_line
    
    read_rest_of_header.return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

read_next_header_line:
    
    mov rax, header_line
    push rax

    mov [header_line.len], 0

    sys_read [connfd], tmp_1B_a, tmp_1B_a.size
    
    read_next_header_line.loop:

        sys_read [connfd], tmp_1B_b, tmp_1B_b.size

        ; network error
        cmp rax, 0
        jl read_next_header_line.line_done

        cmp [tmp_1B_b], 10 ; \n
        jne read_next_header_line.read_next_byte
        cmp [tmp_1B_a], 13 ; \r
        jne read_next_header_line.read_next_byte

        jmp read_next_header_line.line_done

        read_next_header_line.read_next_byte:

        pop rax
        mov cl, [tmp_1B_a]
        mov [rax], cl
        inc rax
        push rax

        inc [header_line.len]

        cmp [header_line.len], HEADER_LINE_MAXLEN
        je read_next_header_line.cut_until_end_of_line

        mov al, [tmp_1B_b]
        mov [tmp_1B_a], al

    jmp read_next_header_line.loop
    
    read_next_header_line.cut_until_end_of_line:

        sys_read [connfd], tmp_1B_b, tmp_1B_b.size

        ; network error
        cmp rax, 0
        jl read_next_header_line.line_done

        cmp [tmp_1B_b], 10 ; \n
        jne read_next_header_line.discard_next_byte
        cmp [tmp_1B_a], 13 ; \r
        jne read_next_header_line.discard_next_byte

        jmp read_next_header_line.line_done

        read_next_header_line.discard_next_byte:

        mov al, [tmp_1B_b]
        mov [tmp_1B_a], al

    jmp read_next_header_line.cut_until_end_of_line

    read_next_header_line.line_done:

    pop rax

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

extract_header_field:
; input:
;   rdi - rdi  8B - prefix
;   rsi - sil  1B - prefix_len
;   rdx - rdx  8B - header_line
;   r10 - r10b 1B - header_line_len
;   r8  - r8   8B - resulting_data - result will be written here (where this points)
;   r9  - r9   8B - resulting_data_len - result will be written here (where this point)
;
; output:
;   returns in rax
;       1 if it was able to extract the header field
;       0 if it was not

; TODO push/pop modified regs

    prefix equ rdi
    prefix_len equ sil
    header_line equ [extract_header_field.stack.header_line]
    header_line_len equ [extract_header_field.stack.header_line_len]
    resulting_data equ r8
    resulting_data_len equ r9

    ; load artificial stack
    mov header_line, rdx
    mov header_line_len, r10b

    ; check for the multipart boundary

    mov dl, prefix_len
    mov dh, header_line_len

    ; received line is too short
    cmp dh, dl
    jle .return_fail

    ; compare strings

    mov rbx, header_line

    .compare_next_char:

        cmp dl, 0
        je .found_boundary_line

        ; read char from expected multipart
        mov cl, [prefix]
        inc prefix

        ; read char from received line
        mov ch, [rbx]
        inc rbx

        ; see if they're the same
        cmp cl, ch
        jne .return_fail

        dec dl

    jmp .compare_next_char

    .found_boundary_line:

        mov dl, prefix_len
        mov dh, header_line_len

        sub dh, dl
        mov rax, resulting_data_len
        mov [rax], dh

        mov rax, resulting_data

        .copy_boundary:

            cmp dh, 0
            je .return_succ

            ; copy
            mov ch, [rbx]
            inc rbx

            mov [rax], ch
            inc rax

            dec dh
        
        jmp .copy_boundary

    .return_succ:
        mov rax, 1
        jmp .return

    .return_fail:
        mov rax, 0
        jmp .return

    restore prefix
    restore prefix_len
    restore header_line
    restore header_line_len
    restore resulting_data
    restore resulting_data_len

    .return:

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; data section

segment readable writable

;;;;;;;;;;;;;; "generic" data

str_nl db 10 ;; new line character
str_nl.size = $ - str_nl

one 4B 1
sizeof_one = $ - one

tmp_1B 1B 0
tmp_1B.size = $ - tmp_1B

tmp_1B_a 1B 0
tmp_1B_a.size = $ - tmp_1B_a

tmp_1B_b 1B 0
tmp_1B_b.size = $ - tmp_1B_b

tmp_4B 1B 0,0,0,0
tmp_4B.size = $ - tmp_4B

tmp_8B 8B 0
tmp_8B.size = $ - tmp_8B

tmp_8B_a 8B 0
tmp_8B_a.size = $ - tmp_8B_a

tmp_fd dq 0

;;;;;;;;;;;;;; other data

;;;;;;;; strings

str_starting_program db "starting server"
str_starting_program_len = $ - str_starting_program

str_warn_folder_existance db "make sure that the following folder exists: "
str_warn_folder_existance.size = $ - str_warn_folder_existance

str_error_num_args db "you need to precify exactly 1 argument: port"
str_error_num_args.size = $ - str_error_num_args


str_http_header_begin db "HTTP/1.1 200 OK", 13, 10
;                      db "Content-Type: text/html; charset=utf-8", 13, 10 ; this seems cool but it fucks with the file upload
                      db "Connection: close", 13, 10
str_http_header_begin.size = $ - str_http_header_begin

str_http_header_begin_404 db "HTTP/1.1 404 Not Found", 13, 10
                          db "Connection: close", 13, 10
str_http_header_begin_404.size = $ - str_http_header_begin_404

    str_http_header_attachment_begin db 'Content-disposition: attachment; filename='
    str_http_header_attachment_begin.size = $ - str_http_header_attachment_begin

    str_http_header_attachment_end db '"', 13, 10
    str_http_header_attachment_end.size = $ - str_http_header_attachment_end

str_http_header_end db 13, 10
str_http_header_end.size = $ - str_http_header_end


str_html_page_404 db "404", 10
str_html_page_404.size = $ - str_html_page_404


str_header_line_multipart_boundary db "Content-Type: multipart/form-data; boundary="
str_header_line_multipart_boundary.size = $ - str_header_line_multipart_boundary

str_header_line_file_upload_filename db 'Content-Disposition: form-data; name="file"; filename="'
; Content-Disposition: form-data; name="file"; filename="todo-hoi4mod"
str_header_line_file_upload_filename.size = $ - str_header_line_file_upload_filename

;;;;;;;; other

;; struct sockaddr_in {
;;     sa_family_t    sin_family;  // 16 bits
;;     in_port_t      sin_port;    // 16 bits
;;     struct in_addr sin_addr;    // 32 bits
;;     uint8_t        sin_zero[8]; // 64 bits
;; }
;;
struc servaddr_in
{
    .sin_family dw 0
    .sin_port   dw 0
    .sin_addr   dd 0
    .sin_zero   dq 0
    .size = $ - .sin_family ;; this should be a comptime variable
}

sockfd dq -1

connfd dq -1

servaddr servaddr_in ;; OMT tova e kato `equ` i `=` (note that moje da dava6 parametri na taq struktura)

cliaddr servaddr_in
cliaddr_size dd servaddr.size


method 1B 0

header_line 1B 0
rept (HEADER_LINE_MAXLEN-1) {
       1B 0
}
header_line.len 1B 0

url 1B 0
rept (URL_MAXLEN) { ; add 1 extra character in case we need to add 0 (so it is a c string)
       1B 0
}
url.len 1B 0

multipart_boundary 1B 0
rept (HEADER_LINE_MAXLEN-1) {
    1B 0
}
multipart_boundary.len 1B 0

file_upload_filename 1B 0
rept (HEADER_LINE_MAXLEN-1) {
    1B 0
}
file_upload_filename.len 1B 0


file_send_upload_fd dq 0

folder_uploaded_files db "/tmp/file-transfer-uploaded-files", 0
folder_uploaded_files.size = $ - folder_uploaded_files - 1
folder_uploaded_files_fd dq 0

folder_static_content db "./static_content", 0
folder_static_content.size = $ - folder_static_content - 1
folder_static_content_fd dq 0

file_recv_buf rb FILE_RECV_BUF
file_recv_buf.size = $ - file_recv_buf


; struct timeval {
;    time_t      tv_sec;   // Number of whole seconds of elapsed time
;    long int    tv_usec;  // Number of microseconds of rest of elapsed time minus tv_sec. Always less than one million
; };
;
struc timeval {
    .tv_sec  8B 0
    .tv_usec 8B 0
    .size = $ - .tv_sec
}

tmp_timeval timeval


; struct linux_dirent {
; 	unsigned long   d_ino;    // 8B
; 	unsigned long   d_off;    // 8B
; 	unsigned short  d_reclen; // 2B
; 	char        d_name[];     // variable length
; };
;
; struc linux_dirent {
;     .d_ino    8B 0
;     .d_off    8B 0
;     .d_reclen 2B 0
;     .d_name   db 0
; rept (512-1) {
;               db 0
;     .size = $ - .d_ino
; }
; }
;
; linux_dirent_buf linux_dirent
;
linux_dirent_buf db 0
rept (512-1) {
    db 0
}
linux_dirent_buf.size = $ - linux_dirent_buf
linux_dirent_buf.offset.d_reclen = 16
linux_dirent_buf.offset.d_name = 18

; read_dir_nread 4B 0
read_dir_nread 8B 0

; read_dir_bpos 4B 0
read_dir_bpos 8B 0


extract_header_field.stack.header_line        8B 0
extract_header_field.stack.header_line_len    1B 0


num_args 8B 0
arg1     8B 0
arg_port 2B 0
